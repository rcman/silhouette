<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-End Three.js 3D Graphics with Baked Lighting</title>
    <style>
        body { margin: 0; padding: 0; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #controls { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; color: white; backdrop-filter: blur(10px); }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }
        input[type="range"] { width: 200px; margin-bottom: 5px; }
        button { background: linear-gradient(45deg, #6366f1, #8b5cf6); border: none; color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin: 5px; transition: transform 0.2s; }
        button:hover { transform: translateY(-2px); }
        #stats { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 10px; font-family: monospace; font-size: 12px; backdrop-filter: blur(10px); }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3 style="margin-top: 0; color: #6366f1;">Graphics Controls</h3>
            <div class="control-group">
                <label>Environment Intensity</label>
                <input type="range" id="envIntensity" min="0" max="5" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Material Roughness</label>
                <input type="range" id="roughness" min="0" max="1" step="0.01" value="0.3">
            </div>
            <div class="control-group">
                <label>Material Metalness</label>
                <input type="range" id="metalness" min="0" max="1" step="0.01" value="0.8">
            </div>
            <div class="control-group">
                <label>Water Animation Speed</label>
                <input type="range" id="waterSpeed" min="0" max="5" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Fire Intensity</label>
                <input type="range" id="fireIntensity" min="0" max="3" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Crystal Refraction</label>
                <input type="range" id="refraction" min="0.8" max="1.5" step="0.01" value="1.2">
            </div>
            <div class="control-group">
                <button id="togglePostProcessing">Toggle Post-Processing</button>
                <button id="toggleParticles">Toggle Particles</button>
                <button id="toggleWireframe">Toggle Wireframe</button>
                <button id="toggleWater">Toggle Water</button>
                <button id="toggleFire">Toggle Fire</button>
            </div>
        </div>
        
        <div id="stats">
            <div id="fps">FPS: --</div>
            <div id="triangles">Triangles: --</div>
            <div id="drawCalls">Draw Calls: --</div>
        </div>
    </div>

    <!-- This is now the only script tag needed -->
    <script type="module">
        // FIX: Import dependencies at the top of the module.
        // This guarantees they are loaded before the code runs.
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js';
        import { LightProbeGenerator } from 'https://cdn.jsdelivr.net/npm/three-stdlib@2.36.0/lights/LightProbeGenerator.js';
        
        // Global variables
        let scene, camera, renderer, clock, lightProbe;
        let sphere, torus, water, crystal;
        let particleSystem, fireParticles;
        let postScene, postCamera, renderTarget, postProcessingQuad;
        let stats = { fps: 0, triangles: 0, drawCalls: 0 };
        let frameCount = 0;
        let lastTime = performance.now();
        let postProcessingEnabled = true;
        let particlesEnabled = true;
        let waterEnabled = true;
        let fireEnabled = true;
        
        init();

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            scene.fog = new THREE.Fog(0x000020, 50, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            document.getElementById('container').appendChild(renderer.domElement);
            
            createEnvironment();
            setupBakedSceneAndProbes(); 
            setupLighting();
            createWater();
            createCrystal();
            createParticles();
            createFireAndSmoke();
            setupPostProcessing();
            setupControls();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createEnvironment() {
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, colorTop: { value: new THREE.Color(0x0077be) }, colorBottom: { value: new THREE.Color(0x89cdf1) }},
                vertexShader: `varying vec3 vWorldPosition; void main() { vec4 worldPosition = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPosition.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `uniform vec3 colorTop; uniform vec3 colorBottom; uniform float time; varying vec3 vWorldPosition; void main() { float h = normalize(vWorldPosition).y; float gradient = smoothstep(-0.2, 0.8, h); vec3 color = mix(colorBottom, colorTop, gradient); float noise = sin(vWorldPosition.x * 0.01 + time) * sin(vWorldPosition.z * 0.01 + time) * 0.1; color += noise; gl_FragColor = vec4(color, 1.0); }`,
                side: THREE.BackSide
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256, { format: THREE.RGBFormat, generateMipmaps: true, minFilter: THREE.LinearMipmapLinearFilter });
            const cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);
            
            sky.userData.update = () => cubeCamera.update(renderer, scene);
            scene.environment = cubeRenderTarget.texture;
        }

        function setupBakedSceneAndProbes() {
            lightProbe = new THREE.LightProbe();
            scene.add(lightProbe);
            
            // This line will now work correctly because LightProbeGenerator is imported.
            lightProbe.copy(LightProbeGenerator.fromCubeRenderTarget(renderer, scene.environment.source));
            lightProbe.intensity = 1.5;

            const gltfLoader = new THREE.GLTFLoader();
            const textureLoader = new THREE.TextureLoader();

            // --- IMPORTANT: YOU MUST REPLACE THESE PATHS! ---
            const lightmapPath = 'GroundLightmap.png'; // Path to your baked lightmap texture
            const glbModelPath = 'bakedGround.glb'; // Path to your .glb model with a second UV set

            const lightmapTexture = textureLoader.load(lightmapPath, (texture) => {
                texture.encoding = THREE.sRGBEncoding;
                texture.flipY = false;
            });

            gltfLoader.load(glbModelPath, (gltf) => {
                const bakedGround = gltf.scene;
                bakedGround.traverse((child) => {
                    if (child.isMesh) {
                        child.material.lightMap = lightmapTexture;
                        child.material.lightMapIntensity = 1.2;
                        child.receiveShadow = true; 
                    }
                });
                bakedGround.position.y = -5;
                scene.add(bakedGround);
            });

            const sphereGeometry = new THREE.SphereGeometry(2, 64, 64);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a90e2, metalness: 0.8, roughness: 0.3, envMapIntensity: 1.5
            });
            sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 0, 0);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
            
            const torusGeometry = new THREE.TorusGeometry(3, 0.5, 32, 128);
            const torusMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, color1: { value: new THREE.Color(0xff6b6b) }, color2: { value: new THREE.Color(0x4ecdc4) } },
                vertexShader: `uniform float time; varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { vec3 pos = position; pos += normal * sin(time * 3.0 + position.x * 5.0) * 0.1; vec4 worldPos = modelMatrix * vec4(pos, 1.0); vWorldPosition = worldPos.xyz; vWorldNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * viewMatrix * worldPos; }`,
                fragmentShader: `uniform float time; uniform vec3 color1; uniform vec3 color2; varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { float mixer = sin(time + vWorldPosition.x * 2.0) * 0.5 + 0.5; vec3 color = mix(color1, color2, mixer); vec3 viewDir = normalize(cameraPosition - vWorldPosition); float fresnel = 1.0 - max(dot(vWorldNormal, viewDir), 0.0); color += pow(fresnel, 3.0) * 0.5; gl_FragColor = vec4(color, 1.0); }`,
                transparent: true
            });
            torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(0, 0, 0);
            torus.castShadow = true;
            scene.add(torus);
        }
        
        function setupLighting() {
            scene.add(new THREE.AmbientLight(0x404040, 0.2)); 
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.set(2048, 2048);
            scene.add(directionalLight);
        }

        function createWater() {
            const waterGeometry = new THREE.PlaneGeometry(50, 50, 128, 128);
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, waterSpeed: { value: 1.0 }, waveHeight: { value: 0.3 }, color1: { value: new THREE.Color(0x006994) }, color2: { value: new THREE.Color(0x0099cc) }, fresnelPower: { value: 3.0 }},
                vertexShader: `uniform float time; uniform float waterSpeed; uniform float waveHeight; varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { vec3 pos = position; float wave1 = sin(pos.x * 0.1 + time * waterSpeed) * waveHeight; float wave2 = sin(pos.y * 0.08 + time * waterSpeed * 1.3) * waveHeight * 0.7; pos.z += wave1 + wave2; vec3 tangent = normalize(vec3(1.0, 0.0, 0.1 * waveHeight * cos(pos.x * 0.1 + time * waterSpeed))); vec3 bitangent = normalize(vec3(0.0, 1.0, 0.08 * waveHeight * 0.7 * cos(pos.y * 0.08 + time * waterSpeed * 1.3))); vec3 normal = cross(tangent, bitangent); vec4 worldPos = modelMatrix * vec4(pos, 1.0); vWorldPosition = worldPos.xyz; vWorldNormal = normalize( (modelMatrix * vec4(normal, 0.0)).xyz ); gl_Position = projectionMatrix * viewMatrix * worldPos; }`,
                fragmentShader: `uniform float time; uniform vec3 color1; uniform vec3 color2; uniform float fresnelPower; varying vec3 vWorldPosition; varying vec3 vWorldNormal; void main() { vec3 viewDir = normalize(cameraPosition - vWorldPosition); float fresnel = 1.0 - max(dot(vWorldNormal, viewDir), 0.0); fresnel = pow(fresnel, fresnelPower); vec3 waterColor = mix(color1, color2, fresnel); gl_FragColor = vec4(waterColor, 0.8 + fresnel * 0.2); }`,
                transparent: true, side: THREE.DoubleSide
            });
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -2;
            scene.add(water);
        }

        function createCrystal() {
            const crystalGeometry = new THREE.IcosahedronGeometry(1.5, 1);
            const crystalMaterial = new THREE.MeshStandardMaterial({ color: 0x88ccff, roughness: 0.1, metalness: 0.2, transmission: 1.0, thickness: 2.0, envMapIntensity: 2.5 });
            crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            crystal.position.set(5, 0, 5);
            crystal.castShadow = true;
            scene.add(crystal);
        }
        
        function createParticles() {
            const particles = new THREE.Points(
                new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(Array.from({length: 3000 * 3}, () => (Math.random() - 0.5) * 100), 3)),
                new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, blending: THREE.AdditiveBlending, transparent: true })
            );
            particleSystem = particles;
            scene.add(particleSystem);
        }

        function createFireAndSmoke() {
             const fireCount = 500;
             const fireGeometry = new THREE.BufferGeometry();
             const firePositions = new Float32Array(fireCount * 3);
             const fireLifetimes = new Float32Array(fireCount);
             const fireVelocities = new Float32Array(fireCount * 3);
             for (let i = 0; i < fireCount; i++) {
                firePositions[i * 3] = (Math.random() - 0.5) * 1.5; firePositions[i * 3 + 1] = 0; firePositions[i * 3 + 2] = (Math.random() - 0.5) * 1.5;
                fireVelocities[i * 3] = (Math.random() - 0.5) * 0.2; fireVelocities[i * 3 + 1] = Math.random() * 1.5 + 1; fireVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                fireLifetimes[i] = Math.random();
            }
            fireGeometry.setAttribute('position', new THREE.BufferAttribute(firePositions, 3));
            fireGeometry.setAttribute('lifetime', new THREE.BufferAttribute(fireLifetimes, 1));
            fireGeometry.setAttribute('velocity', new THREE.BufferAttribute(fireVelocities, 3));
            const fireMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, intensity: { value: 1.5 } },
                vertexShader: `uniform float time; attribute float lifetime; attribute vec3 velocity; varying float vLifetime; void main() { vLifetime = mod(lifetime + time * 0.5, 1.0); vec3 pos = position + velocity * vLifetime * 5.0; vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0); gl_PointSize = (1.0 - vLifetime) * 20.0 * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`,
                fragmentShader: `uniform float intensity; varying float vLifetime; void main() { float r = distance(gl_PointCoord, vec2(0.5)); if (r > 0.5) discard; vec3 color = mix(vec3(1.0, 0.9, 0.2), vec3(1.0, 0.2, 0.0), vLifetime); float alpha = (1.0 - r * 2.0) * (1.0 - vLifetime) * intensity; gl_FragColor = vec4(color, alpha); }`,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            fireParticles = new THREE.Points(fireGeometry, fireMaterial);
            fireParticles.position.set(-5, -4, -5);
            scene.add(fireParticles);
        }
        
        function setupPostProcessing() {
            renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
            postScene = new THREE.Scene();
            postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const postProcessMaterial = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: { value: null }, time: { value: 0 }, bloomIntensity: { value: 1.5 }, vignetteStrength: { value: 0.5 }},
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`,
                fragmentShader: `uniform sampler2D tDiffuse; uniform float time; uniform float bloomIntensity; uniform float vignetteStrength; varying vec2 vUv; void main() { vec3 color = texture2D(tDiffuse, vUv).rgb; float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722)); if (brightness > 0.8) { color += color * bloomIntensity * (brightness - 0.8); } float vignette = 1.0 - smoothstep(0.3, 0.8, distance(vUv, vec2(0.5)) * vignetteStrength); color *= vignette; float grain = (fract(sin(dot(vUv + time, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.05; color += grain; gl_FragColor = vec4(color, 1.0); }`
            });
            postProcessingQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), postProcessMaterial);
            postScene.add(postProcessingQuad);
        }
        
        function setupControls() {
            document.getElementById('envIntensity').addEventListener('input', (e) => { if(sphere) sphere.material.envMapIntensity = parseFloat(e.target.value); });
            document.getElementById('roughness').addEventListener('input', (e) => { if(sphere) sphere.material.roughness = parseFloat(e.target.value); });
            document.getElementById('metalness').addEventListener('input', (e) => { if(sphere) sphere.material.metalness = parseFloat(e.target.value); });
            document.getElementById('waterSpeed').addEventListener('input', (e) => { if(water) water.material.uniforms.waterSpeed.value = parseFloat(e.target.value); });
            document.getElementById('fireIntensity').addEventListener('input', (e) => { if(fireParticles) fireParticles.material.uniforms.intensity.value = parseFloat(e.target.value); });
            document.getElementById('refraction').addEventListener('input', (e) => { if(crystal) crystal.material.thickness = parseFloat(e.target.value) * 2; });
            document.getElementById('togglePostProcessing').addEventListener('click', () => postProcessingEnabled = !postProcessingEnabled);
            document.getElementById('toggleParticles').addEventListener('click', () => { particlesEnabled = !particlesEnabled; if(particleSystem) particleSystem.visible = particlesEnabled; });
            document.getElementById('toggleWireframe').addEventListener('click', () => { if(sphere) sphere.material.wireframe = !sphere.material.wireframe; if(torus) torus.material.wireframe = !torus.material.wireframe; });
            document.getElementById('toggleWater').addEventListener('click', () => { waterEnabled = !waterEnabled; if(water) water.visible = waterEnabled; });
            document.getElementById('toggleFire').addEventListener('click', () => { fireEnabled = !fireEnabled; if(fireParticles) fireParticles.visible = fireEnabled; });
            
            const spherical = new THREE.Spherical(15, Math.PI / 2.2, 0);
            let mouseDown = false;
            let lastMouseX = 0, lastMouseY = 0;
            const updateCameraPosition = () => {
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
            };
            updateCameraPosition();
            renderer.domElement.addEventListener('mousedown', (e) => { mouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
            document.addEventListener('mouseup', () => mouseDown = false);
            document.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                spherical.theta -= (e.clientX - lastMouseX) * 0.005;
                spherical.phi -= (e.clientY - lastMouseY) * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                updateCameraPosition();
                lastMouseX = e.clientX; lastMouseY = e.clientY;
            });
            renderer.domElement.addEventListener('wheel', (e) => {
                spherical.radius *= e.deltaY > 0 ? 1.1 : 0.9;
                spherical.radius = Math.max(5, Math.min(50, spherical.radius));
                updateCameraPosition();
            });
        }
        
        function updateStats() {
            const currentTime = performance.now();
            frameCount++;
            if (currentTime >= lastTime + 1000) {
                stats.fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                stats.triangles = renderer.info.render.triangles;
                stats.drawCalls = renderer.info.render.calls;
                frameCount = 0; lastTime = currentTime;
                document.getElementById('fps').textContent = `FPS: ${stats.fps}`;
                document.getElementById('triangles').textContent = `Triangles: ${stats.triangles.toLocaleString()}`;
                document.getElementById('drawCalls').textContent = `Draw Calls: ${stats.drawCalls}`;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            if(sphere) sphere.position.y = Math.sin(elapsedTime) * 0.5;
            if(torus) { torus.rotation.x += 0.005; torus.rotation.y += 0.003; }
            if(crystal) crystal.rotation.y += 0.004;
            if(particleSystem) particleSystem.rotation.y += 0.001;

            if(torus) torus.material.uniforms.time.value = elapsedTime;
            if(water) water.material.uniforms.time.value = elapsedTime;
            if(fireParticles) fireParticles.material.uniforms.time.value = elapsedTime;
            
            const sky = scene.children[0];
            if (sky && sky.userData.update) {
                sky.material.uniforms.time.value = elapsedTime * 0.1;
                sky.userData.update();
            }
            
            updateStats();
            
            if (postProcessingEnabled) {
                renderer.setRenderTarget(renderTarget);
                renderer.clear();
                renderer.render(scene, camera);
                postProcessingQuad.material.uniforms.tDiffuse.value = renderTarget.texture;
                postProcessingQuad.material.uniforms.time.value = elapsedTime;
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.render(postScene, postCamera);
            } else {
                renderer.render(scene, camera);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (renderTarget) renderTarget.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>